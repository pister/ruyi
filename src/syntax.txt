# Ruyi Program Language Syntax

# Programs
<root> ::= <global declarations>?

# Declarations
<global declarations> ::= <global declaration> *
<global declaration> ::= <variable declaration> | <function declaration> | <class declaration> | <interface declaration> | <constant declaration> | <statement ends>

<variable declaration> ::= KW_VAR <variable declaration tail>
<function declaration> ::= KW_FUNC IDENTITY LPARAN <formal parameter list>? RPARAN <type>? <function body>
<class declaration> ::= KW_CLASS IDENTITY <class body>
<interface declaration> ::= KW_INTERFACE IDENTITY <interface body>
<constant declaration> ::= KW_CONST IDENTITY ASSIGN <constant initializer>

<class body> ::= LBRACE <class body declarations>? RBRACE
<class body declarations> ::= <class body declaration> | <class body declarations> <class body declaration>

<variable declaration tail> ::= (LBRACKET RBRACKET) * IDENTITY (ASSIGN <expression>) ?

<formal parameter list> ::= <formal parameter> | <formal parameter list> COMMA <formal parameter>
<formal parameter> ::= IDENTITY DOT3? <type>
<method body> ::= <block> | <statement ends>


# Blocks
<block> ::= LBRACE <block statements>? RBRACE
<block statements> ::= <block statement> | <block statements> <block statement>
<block statement> ::= <local variable declaration statement> | <statement>
<local variable declaration statement> ::= <local variable declaration> <statement ends>
<local variable declaration> ::= <variable declaration> | <local direct assign>
<local direct assign> ::= IDENTITY COLON_ASSIGN <expression>
<statement> ::= <labeled statement> | <if statement> | <while statement> | <for statement> | <expression statement> | <switch statement> | <try statement>
<sub statement> ::= <empty statement> | <break statement> | <continue statement> | <return statement>

<expression statement> ::= <statement expression> <statement ends>
<statement expression> ::= <assignment> | <postincrement expression> | <postdecrement expression>  | <class instance creation expression> | <function invocation>

<empty statement> ::= <statement ends>
<labeled statement> ::= IDENTITY COLON <statement>


#
<statement ends> ::= <statement end> | <statement ends> <statement end>
<statement end> ::= SEMICOLON | EOL

# Expression
<expression> ::= <assignment expression>
<assignment expression> ::= <conditional expression> | <assignment>
<assignment> ::= <left hand side> <assignment operator> <assignment expression>
<left hand side> ::= <name> | <field access> | <array access>
<assignment operator> ::= ASSIGN | MUL_ASS | DIV_ASS | MOD_ASS | ADD_ASS | SUB_ASS | SHFT_LEFT_ASS | SHFT_RIGHT_ASS | BIT_AND_ASS | BIT_XOR_ASS | BIT_OR_ASS
<conditional expression> ::= <conditional or expression> (QM <expression> Ruyi_tt_COLON <conditional expression>)?
<conditional or expression> ::= <conditional and expression> (LOGIC_OR <conditional and expression>)*
<conditional and expression> ::= <bit or expression> ( LOGIC_AND <bit or expression>)*
<bit or expression> ::= <bit and expression> (BIT_OR <bit and expression>)*
<bit and expression> ::= <equality expression> (BIT_AND <equality expression>)*
<equality expression> ::= <relational expression> ((EQUALS | NOT_EQUALS) <relational expression>)?
<relational expression> ::= <shift expression> ((KW_INSTANCEOF <reference type>) | ((LT | GT | LTE | GTE) <shift expression>)) ?
<shift expression> ::= <additive expression> ((SHFT_LEFT | SHFT_RIGHT) <additive expression>)?
<additive expression> ::= <multiplicative expression> ((ADD | SUB) <multiplicative expression>)*
<multiplicative expression> ::= <unary expression> ((MUL | DIV | MOD) <unary expression>)*

<unary expression> ::= ADD <unary expression> | SUB <unary expression> | <not plus minus expression>
<not plus minus expression> ::= BIT_INVERSE <unary expression> | LOGIC_NOT <unary expression> | <primary cast expression> | <postfix expression>
<primary cast expression> ::=  LPARAN <primary type> RPARAN  <unary expression> # not support reference cast now!!!
<postdecrement expression> ::= <postfix expression> DEC
<postincrement expression> ::= <postfix expression> INC
<postfix expression> ::= <primary> | <name> | <postincrement expression> | <postdecrement expression>
<field access> ::= <primary> DOT IDENTITY
<primary> ::= <primary no new array> | <array creation> | <map make creation> 
<primary no new collection> ::= <literal> | KW_THIS | LPARAN <expression> RPARAN | <field access> | <array access> | <instance creation> | <function invocation>

<instance creation> ::= IDENTITY LBRACE (IDENTITY COLON <expression> (COMMA IDENTITY COLON <expression>)*)?  RBRACE

<argument list> ::= <expression> ( COMMA <expression> )*

<array creation> ::= <array creation with cap> | <array creation with init>

<array creation with cap> ::= KW_ARRAY LPARAN <array type> COMMA <expression> (COMMA <expression>)? RPARAN
<array creation with init> ::= <array type> LBRACKET (<expression> (COMMA <expression>)*)?  RBRACKET
<map creation> ::= KW_MAP LPARAN <map type> RPARAN

<function invocation> ::= <expression> LPARAN <argument list>? RPARAN

<array access> ::= <array variable access> | <variable primary access>
<array variable access> ::= <name> LBRACKET <expression> RBRACKET
<variable primary access> ::= <primary no new array> LBRACKET <expression> RBRACKET

# Types
<type> ::= <primitive type> | <reference type>
<primitive type> ::= <numeric type> | bool
<numeric type> ::= <integral type> | <floating-point type>
<integral type> ::= KW_BYTE | KW_SHORT| KW_INT | KW_RUNE | KW_LONG
<floating-point type> ::= KW_FLOAT | KW_DOUBLE
<reference type> ::= IDENTITY | <array type> | <map type>
<array type> ::= LBRACKET RBRACKET <type>
<map type> ::= LBRACKET IDENTITY RBRACKET <type>
<raw type> ::= <primitive type> | IDENTITY


# Tokens
<name> ::= IDENTITY (DOT IDENTITY) *
<literal> ::= INTEGER | FLOAT | KW_TRUE | KW_FALSE | RUNE | STRING | KW_NULL
